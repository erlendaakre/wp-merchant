package com.frostvoid.wpMerchant.services

import akka.actor.{Actor, ActorLogging}
import akka.pattern.ask
import com.frostvoid.wpMerchant.api.{GetItemRequest, _}
import com.frostvoid.wpMerchant.util.{AkkaSupport, IdGenerator}

import scala.concurrent.Await
import scala.concurrent.duration._

/**
  * Handles retrieval and storage of Offers in a mutable map
  */
class OfferWorker extends Actor with AkkaSupport with ActorLogging with IdGenerator {

  private val offerStore = collection.mutable.Map.empty[Int, Offer] // Int = Offer.id

  private val merchantWorker = Await.result(context.actorSelection("/user/merchantWorker").resolveOne(10.seconds), 15.seconds)
  private val itemWorker = Await.result(context.actorSelection("/user/itemWorker").resolveOne(10.seconds), 15.seconds)


  override def receive: Receive = {
    case GetOfferRequest(id) => sender() ! offerStore.get(id).fold(OfferNotFound: OfferReply)(o => OfferReturned(o))
    case AddOfferRequest(merchantId, itemId, price, currency) => sender() ! addOffer(merchantId, itemId, price, currency)
  }

  override def postStop: Unit = log.info("Shutting down")

  override def preStart: Unit = log.info("Starting up")

  private def addOffer(merchantId: Int, itemId: Int, price: Double, currency: String): OfferReply = {
    // asking merchant/item workers to get data by id (to verify the IDs)
    val merchantReq = merchantWorker ? GetMerchantRequest(merchantId)
    val itemReq = itemWorker ? GetItemRequest(itemId)

    val f = for {
      merchantRes <- merchantReq
      itemRes <- itemReq
    } yield {
      val merchantOpt = merchantRes match {
        case m: MerchantReturned => Option(m.merchant)
        case _ => None
      }
      val itemOpt = itemRes match {
        case i: ItemReturned => Option(i.item)
        case _ => None
      }

      if (price < 0) OfferNotCreatedBecauseNegativePrice
      else if (merchantOpt.isEmpty) OfferNotCreatedBecauseMerchantInvalid
      else if (itemOpt.isEmpty) OfferNotCreatedBecauseItemInvalid
      else {
        val result = for {
          merchant <- merchantOpt
          item <- itemOpt
        } yield createOffer(merchant, item, price, currency)
        result.getOrElse(OfferNotCreated)
      }
    }
    // NOTE: blocks this entire worker while waiting for merchant/item workers
    // This could be improved by spawning a worker for each request, or having merchant/item worker send back
    Await.result(f, 15.seconds)
  }

  private def createOffer(merchant: Merchant, item: Item, price: Double, currency: String): OfferReply = {
    val id = generateId
    log.info(s"Adding offer by ${merchant.name} for ${item.name}, autogenerated id is '$id'")
    if (offerStore.contains(id)) {
      log.warning(s"Autogenerated ID collision, trying to add offer by ${merchant.name} for ${item.name} to item store with id $id")
      OfferNotCreated
    }
    else {
      val o = Offer(id, merchant.id, item.id, price, currency)
      offerStore.put(id, o)
      OfferReturned(o)
    }
  }
}

